library(writexl)
datos = data.frame()
n <-  18
numsem <- c(6, 12, 24)

for (k in numsem) {
  zona <- matrix(rep(0, n * n), nrow = n, ncol = n)
  x <- rep(0, k) # ocupamos almacenar las coordenadas x de las semillas
  y <- rep(0, k) # igual como las coordenadas y de las semillas
  
  for (semilla in 1:k) {
    while (TRUE) { #hasta que hallamos una posicion vacia para la semilla
      fila <- sample(1:n, 1)
      columna <- sample(1:n, 1)
      if (zona[fila, columna] == 0){
        zona[fila, columna] = semilla
        x[semilla] <- columna
        y[semilla] <- fila
        break
      }
    }
  }
  
  celda <- function(pos){
    fila <- floor((pos - 1) / n) + 1
    columna <- ((pos - 1) %% n) + 1
    if (zona[fila, columna] > 0){ #es una semilla
      return(zona[fila, columna])
    } else{
      cercano <- NULL #sin valor por el momento
      menor <- n * sqrt(2) #mayor posible para comenzar la busqueda
      for (semilla in 1:k){
        dx <- columna - x[semilla]
        dy <- fila - y[semilla]
        dist <- sqrt(dx^2 + dy^2)
        if (dist < menor){
          cercano <- semilla
          menor <- dist
        }
      }
      return(cercano)
    }
  }
  
  celdas <- sapply(1:(n * n), function(p) celda(p))
  voronoi <- matrix(celdas, nrow = n, ncol = n, byrow=TRUE)
  rotate <- function(x) t(apply(x, 2, rev))
  sem=paste("p4s", "-", k, ".png", sep="")
  png(sem)
  par(mar = c(0,0,0,0))
  image(rotate(zona), col=rainbow(k+1), xaxt='n', yaxt='n')
  graphics.off()
  cel=paste("p4c", "-", k, ".png", sep="")
  png(cel)
  par(mar = c(0,0,0,0))
  image(rotate(voronoi), col=rainbow(k+1), xaxt='n', yaxt='n')
  graphics.off()
  
limite <- n # grietas de que largo minimo queremos graficar
  
inicio <- function() {
    direccion <- sample(1:4, 1)
    xg <- NULL
    yg <- NULL
    if (direccion == 1) { # horiz izq -> der
      xg <- 1
      yg <- sample(1:n, 1)
    } else if (direccion == 2) { # vertical abajo -> arriba
      xg <- sample(1:n, 1)
      yg <- 1
    } else if (direccion == 3) { # horiz der -> izq
      xg <- n
      yg <- sample(1:n, 1)
    } else { # vertical arriba -> abajo
      xg <- sample(1:n, 1)
      yg <- n
    }
    return(c(xg, yg))
  }
  
  vp <- data.frame(numeric(), numeric()) # posiciones de posibles vecinos
  for (dx in -1:1) {
    for (dy in -1:1) {
      if (dx != 0 | dy != 0) { # descartar la posicion misma
        vp <- rbind(vp, c(dx, dy))
      }
    }
  }
  names(vp) <- c("dx", "dy")
  vc <- dim(vp)[1]
  
  propaga <- function(replica) {
    prob <- 1 # interno a la celda (inicial)
    dificil <- 0.99 # bajada al interior
    grieta <- voronoi # marcamos la grieta en una copia
    i <- inicio() # posicion inicial al azar
    xg <- i[1]
    yg <- i[2]
    largo <- 0
    while (TRUE) { # hasta que la propagacion termine
      grieta[yg, xg] <- 0 # usamos el cero para marcar la grieta
      largo <-  largo + 1
      frontera <- numeric()
      interior <- numeric()
      for (v in 1:vc) {
        vecino <- vp[v,]
        xs <- xg + vecino$dx # columna del vecino potencial
        ys <- yg + vecino$dy # fila del vecino potencial
        if (xs > 0 & xs <= n & ys > 0 & ys <= n) { # no sale de la zona
          if (grieta[ys, xs] > 0) { # aun no hay grieta ahi
            if (voronoi[yg, xg] == voronoi[ys, xs]) {
              interior <- c(interior, v)
            } else { # frontera
              frontera <- c(frontera, v)
            }
          }
        }
      }
      elegido <- 0
      if (length(frontera) > 0) { # siempre tomamos frontera cuando haya
        if (length(frontera) > 1) {
          elegido <- sample(frontera, 1)
        } else {
          elegido <- frontera # sample sirve con un solo elemento
        }
        prob <- 1 # estamos nuevamente en la frontera
      } else if (length(interior) > 0) { # no hubo frontera para propagar
        if (runif(1) < prob) { # intentamos en el interior
          if (length(interior) > 1) {
            elegido <- sample(interior, 1)
          } else {
            elegido <- interior
          }
          prob <- dificil * prob # mas dificil a la siguiente
        }
      }
      if (elegido > 0) { # si se va a propagar
        vecino <- vp[elegido,]
        xg <- xg + vecino$dx
        yg <- yg + vecino$dy
      } else {
        break # ya no se propaga
      }
    }
    if (largo >= limite) {
      png(paste("p4g_", replica, ".png", sep=""))
      par(mar = c(0,0,0,0))
      image(rotate(grieta), col=rainbow(k+1), xaxt='n', yaxt='n')
      graphics.off()
    }
    return(grieta)
  }

  suppressMessages(library(doParallel))
  registerDoParallel(makeCluster(detectCores() - 1))
  lagrieta <- foreach(r = 1:1, .combine=c) %dopar% propaga(r)
  stopImplicitCluster()
  lagrieta
  datos = rbind(datos, lagrieta)
  write_xlsx(datos, "misdatos.xlsx")
}

#PRUEBA ESTADÍSTICA
library(readxl)
library(ggplot2)
library(tidyverse)
library(ggpubr)
library(car)

ruta_excel = "C:\\Users\\beren\\OneDrive\\Escritorio\\Maestría\\2do semestre\\5. Simulación computacional de nanomateriales\\Tareas\\Tarea_4\\datos.xlsx"
datos = read_excel(ruta_excel)
datos

datos$Semillas= as.factor(datos$Semillas) #crear vector a partir del dataframe

diagrama = ggplot(data = datos, aes(x = Semillas, y = Distancia, fill = Semillas)) +
  geom_boxplot() + theme_bw() + labs(x = "Cantidad de semillas", y = "Distancia Manhattan")

diagrama

#Estadísticas descriptivas
datos = datos %>%
  rstatix::reorder_levels(Semillas, order = c("6", "12", "24"))

datos %>%
  group_by(Semillas) %>%
  get_summary_stats(Distancia, type = "mean_sd")

#SUPUESTOS PARA ANOVA
#1:Outliers
datos %>%
  group_by(Semillas) %>%
  identify_outliers(Distancia)

#2:Normalidad con residuales
normalidad = lm(Distancia ~ Semillas, data = datos)
head(datos)
head(normalidad$fitted.values)
head(normalidad$residuals)

grafica1 = ggqqplot(residuals(normalidad))+
  labs(title = 'Normalidad con residuales')
grafica1

shapiro_test(residuals(normalidad))

datos %>%
  group_by(Semillas) %>%
  shapiro_test(Distancia)

#3:Homogeneidad de varianza con prueba Levene
datos %>%
  levene_test(Distancia~Semillas)


#PRUEBA ESTADÍSTICA KRUSKAL WALLIS
kruskal.test(Distancia ~ Semillas, data = datos)

pairwise.wilcox.test(datos$Distancia, datos$Semillas)

grafica2 = ggline(data = datos, x = "Semillas", y = "Distancia", add = c("mean_se", "jitter"))
grafica2